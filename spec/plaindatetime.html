<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaindatetime-objects">
  <h1>Temporal.PlainDateTime Objects</h1>
  <p>A Temporal.PlainDateTime object is an immutable Object that contains integers corresponding to a particular year, month, day, hour, minute, second, millisecond, microsecond, and nanosecond.</p>

  <emu-clause id="sec-temporal-plaindatetime-constructor">
    <h1>The Temporal.PlainDateTime Constructor</h1>
    <p>
      The Temporal.PlainDateTime constructor is the %Temporal.PlainDateTime% intrinsic object.
      When called as a constructor, it creates and initializes a new Temporal.PlainDateTime object.
    </p>
    <p>
      The Temporal.PlainDateTime constructor is designed to be subclassable.
      It may be used as the value of an extends clause of a class definition.
      Subclass constructors that intend to inherit the specified DateTime behaviour must include a super call to the %Temporal.PlainDateTime% constructor to create and initialize subclass instances with the necessary internal slots.
    </p>

    <emu-clause id="sec-temporal.datetime">
      <h1>Temporal.PlainDateTime ( _isoYear_, _isoMonth_, _isoDay_ [ , _hour_ [ , _minute_ [ , _second_ [ , _millisecond_ [ , _microsecond_ [ , _nanosecond_ [ , _calendarLike_ ] ] ] ] ] ] ] )</h1>
      <p>
        When the `Temporal.PlainDateTime` function is called, the following steps are taken:
      </p>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _isoYear_ be ? ToInteger(_isoYear_).
        1. Let _isoMonth_ be ? ToInteger(_isoMonth_).
        1. Let _isoDay_ be ? ToInteger(_isoDay_).
        1. Let _hour_ be ? ToInteger(_hour_).
        1. Let _minute_ be ? ToInteger(_minute_).
        1. Let _second_ be ? ToInteger(_second_).
        1. Let _millisecond_ be ? ToInteger(_millisecond_).
        1. Let _microsecond_ be ? ToInteger(_microsecond_).
        1. Let _nanosecond_ be ? ToInteger(_nanosecond_).
        1. If _calendarLike_ is *undefined*, then
          1. Set _calendar_ to ? GetISO8601Calendar().
        1. Else,
          1. Set _calendar_ to ? ToTemporalCalendar(_calendarLike_).
        1. Return ? CreateTemporalDateTime(_isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindatetime-constructor">
    <h1>Properties of the Temporal.PlainDateTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.PlainDateTime constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.PlainDateTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal-plaindatetime-prototype">
      <h1>Temporal.PlainDateTime.prototype</h1>
      <p>The initial value of `Temporal.PlainDateTime.prototype` is %Temporal.PlainDateTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime-@@species">
      <h1>get Temporal.PlainDateTime [ @@species ]</h1>
      <p>
        `Temporal.PlainDateTime[@@species]` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>

      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.from">
      <h1>Temporal.PlainDateTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _constructor_ be the *this* value.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Return ? CreateTemporalDateTimeFromStatic(_constructor_, _item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[Hour]], _item_.[[Minute]], _item_.[[Second]], _item_.[[Millisecond]], _item_.[[Microsecond]], _item_.[[Nanosecond]], _item_.[[Calendar]]).
        1. Return ? ToTemporalDateTime(_item_, _constructor_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.compare">
      <h1>Temporal.PlainDateTime.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDateTime(_one_).
        1. Set _two_ to ? ToTemporalDateTime(_two_).
        1. Let _result_ be ! CompareTemporalDateTime(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _one_.[[Hour]], _one_.[[Minute]], _one_.[[Second]], _one_.[[Millisecond]], _one_.[[Microsecond]], _one_.[[Nanosecond]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _two_.[[Hour]], _two_.[[Minute]], _two_.[[Second]], _two_.[[Millisecond]], _two_.[[Microsecond]], _two_.[[Nanosecond]]).
        1. If _result_ ‚â† 0, then
          1. Return ùîΩ(_result_).
        1. Return ùîΩ(? CompareCalendar(_one_.[[Calendar]], _two_.[[Calendar]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindatetime-prototype-object">
    <h1>Properties of the Temporal.PlainDateTime Prototype Object</h1>

    <p>The Temporal.PlainDateTime prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.PlainDateTime.prototype%</dfn>.
      <li>is itself an ordinary object.
      <li>is not a Temporal.PlainDateTime instance and does not have a [[InitializedTemporalDateTime]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id="sec-temporal.datetime.prototype.constructor">
      <h1>Temporal.PlainDateTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainDateTime.prototype.constructor` is %Temporal.PlainDateTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype-@@tostringtag">
      <h1>Temporal.PlainDateTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value `"Temporal.PlainDateTime"`.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.calendar">
      <h1>get Temporal.PlainDateTime.prototype.calendar</h1>
      <p>
        `Temporal.PlainDateTime.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.year">
      <h1>get Temporal.PlainDateTime.prototype.year</h1>
      <p>
        `Temporal.PlainDateTime.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"year"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.month">
      <h1>get Temporal.PlainDateTime.prototype.month</h1>
      <p>
        `Temporal.PlainDateTime.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"month"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.day">
      <h1>get Temporal.PlainDateTime.prototype.day</h1>
      <p>
        `Temporal.PlainDateTime.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"day"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.hour">
      <h1>get Temporal.PlainDateTime.prototype.hour</h1>
      <p>
        `Temporal.PlainDateTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Hour]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.minute">
      <h1>get Temporal.PlainDateTime.prototype.minute</h1>
      <p>
        `Temporal.PlainDateTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Minute]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.second">
      <h1>get Temporal.PlainDateTime.prototype.second</h1>
      <p>
        `Temporal.PlainDateTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Second]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.millisecond">
      <h1>get Temporal.PlainDateTime.prototype.millisecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Millisecond]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.microsecond">
      <h1>get Temporal.PlainDateTime.prototype.microsecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Microsecond]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.nanosecond">
      <h1>get Temporal.PlainDateTime.prototype.nanosecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Nanosecond]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.dayofweek">
      <h1>get Temporal.PlainDateTime.prototype.dayOfWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"dayOfWeek"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.dayofyear">
      <h1>get Temporal.PlainDateTime.prototype.dayOfYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"dayOfYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.weekofyear">
      <h1>get Temporal.PlainDateTime.prototype.weekOfYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"weekOfYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.daysinweek">
      <h1>get Temporal.PlainDateTime.prototype.daysInWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInWeek"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.daysinyear">
      <h1>get Temporal.PlainDateTime.prototype.daysInYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.daysinmonth">
      <h1>get Temporal.PlainDateTime.prototype.daysInMonth</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInMonth"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.monthsinyear">
      <h1>get Temporal.PlainDateTime.prototype.monthsInYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"monthsInYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.inleapyear">
      <h1>get Temporal.PlainDateTime.prototype.inLeapYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"inLeapYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _dateTime_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.with">
      <h1>Temporal.PlainDateTime.prototype.with ( _temporalDateTimeLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalDateTimeLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If Type(_temporalDateTimeLike_) is not Object, then
          1. Let _isoString_ be ? ToString(_temporalDateTimeLike_).
          1. Set _temporalDateTimeLike_ to ? RelevantTemporalObjectFromString(_isoString_).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
        1. Let _partialDateTime_ be ? ToPartialDateTime(_temporalDateTimeLike_, _fieldNames_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _fields_ be ? ToTemporalDateTimeFields(_datetime_, _fieldNames_).
        1. Let _temporalDate_ be <mark>TODO: create via calendar.dateFromFields</mark>.
        1. Let _year_ be _temporalDate_.[[ISOYear]].
        1. Let _month_ be _temporalDate_.[[ISOMonth]].
        1. Let _day_ be _temporalDate_.[[ISODay]].
        1. If _partialDateTime_.[[Hour]] is not *undefined*, then
          1. Let _hour_ be _partialDateTime_.[[Hour]].
        1. Else,
          1. Let _hour_ be _dateTime_.[[Hour]].
        1. If _partialDateTime_.[[Minute]] is not *undefined*, then
          1. Let _minute_ be _partialDateTime_.[[Minute]].
        1. Else,
          1. Let _minute_ be _dateTime_.[[Minute]].
        1. If _partialDateTime_.[[Second]] is not *undefined*, then
          1. Let _second_ be _partialDateTime_.[[Second]].
        1. Else,
          1. Let _second_ be _dateTime_.[[Second]].
        1. If _partialDateTime_.[[Millisecond]] is not *undefined*, then
          1. Let _millisecond_ be _partialDateTime_.[[Millisecond]].
        1. Else,
          1. Let _millisecond_ be _dateTime_.[[Millisecond]].
        1. If _partialDateTime_.[[Microsecond]] is not *undefined*, then
          1. Let _microsecond_ be _partialDateTime_.[[Microsecond]].
        1. Else,
          1. Let _microsecond_ be _dateTime_.[[Microsecond]].
        1. If _partialDateTime_.[[Nanosecond]] is not *undefined*, then
          1. Let _nanosecond_ be _partialDateTime_.[[Nanosecond]].
        1. Else,
          1. Let _nanosecond_ be _dateTime_.[[Nanosecond]].
        1. Let _result_ be ? RegulateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_).
        1. Assert: ! ValidateDateTime(_year_, _month_, _day_, _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTimeFromInstance(_dateTime_, _year_, _month_, _day_, _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.add">
      <h1>Temporal.PlainDateTime.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _result_ be ? AddDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _dateTime_.[[Calendar]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], _overflow_).
        1. Assert: ! ValidateDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTimeFromInstance(_dateTime_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.subtract">
      <h1>Temporal.PlainDateTime.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _result_ be ? AddDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _dateTime_.[[Calendar]], ‚àí_duration_.[[Years]], ‚àí_duration_.[[Months]], ‚àí_duration_.[[Weeks]], ‚àí_duration_.[[Days]], ‚àí_duration_.[[Hours]], ‚àí_duration_.[[Minutes]], ‚àí_duration_.[[Seconds]], ‚àí_duration_.[[Milliseconds]], ‚àí_duration_.[[Microseconds]], ‚àí_duration_.[[Nanoseconds]], _overflow_).
        1. Assert: ! ValidateDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTimeFromInstance(_dateTime_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.until">
      <h1>Temporal.PlainDateTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        The `until` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Set _other_ to ? ToTemporalDateTime(_other_).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _calendarID_ be ? CalendarToString(_calendar_).
        1. Let _otherCalendar_ be _other_.[[Calendar]].
        1. Let _otherCalendarID_ be ? CalendarToString(_otherCalendar_).
        1. If _calendarID_ ‚â† _otherCalendarID_, throw a *RangeError* exception.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, ¬´ ¬ª, *"nanoseconds"*).
        1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalDurationUnits(*"days"*, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ ¬ª, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _diff_ be ? DifferenceDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _other_.[[ISOYear]], _other_.[[ISOMonth]], _other_.[[ISODay]], _other_.[[ISOHour]], _other_.[[ISOMinute]], _other_.[[ISOSecond]], _other_.[[ISOMillisecond]], _other_.[[ISOMicrosecond]], _other_.[[ISONanosecond]], _calendar_, _largestUnit_).
        1. Let _roundResult_ be ? RoundDuration(_diff_.[[Years]], _diff_.[[Months]], _diff_.[[Weeks]], _diff_.[[Days]], _diff_.[[Hours]], _diff_.[[Minutes]], _diff_.[[Seconds]], _diff_.[[Milliseconds]], _diff_.[[Microseconds]], _diff_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _dateTime_).
        1. Let _result_ be ! BalanceDuration(_roundResult_.[[Days]], _roundResult_.[[Hours]], _roundResult_.[[Minutes]], _roundResult_.[[Seconds]], _roundResult_.[[Milliseconds]], _roundResult_.[[Microseconds]], _roundResult_.[[Nanoseconds]], _largestUnit_).
        1. Return ? CreateTemporalDuration(_roundResult_.[[Years]], _roundResult_.[[Months]], _roundResult_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.since">
      <h1>Temporal.PlainDateTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        The `since` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Set _other_ to ? ToTemporalDateTime(_other_).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _calendarID_ be ? CalendarToString(_calendar_).
        1. Let _otherCalendar_ be _other_.[[Calendar]].
        1. Let _otherCalendarID_ be ? CalendarToString(_otherCalendar_).
        1. If _calendarID_ ‚â† _otherCalendarID_, throw a *RangeError* exception.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, ¬´ ¬ª, *"nanoseconds"*).
        1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalDurationUnits(*"days"*, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ ¬ª, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _diff_ be ? DifferenceDateTime(_other_.[[ISOYear]], _other_.[[ISOMonth]], _other_.[[ISODay]], _other_.[[ISOHour]], _other_.[[ISOMinute]], _other_.[[ISOSecond]], _other_.[[ISOMillisecond]], _other_.[[ISOMicrosecond]], _other_.[[ISONanosecond]], _dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _calendar_, _largestUnit_).
        1. Let _roundResult_ be ? RoundDuration(‚àí_diff_.[[Years]], ‚àí_diff_.[[Months]], ‚àí_diff_.[[Weeks]], ‚àí_diff_.[[Days]], ‚àí_diff_.[[Hours]], ‚àí_diff_.[[Minutes]], ‚àí_diff_.[[Seconds]], ‚àí_diff_.[[Milliseconds]], ‚àí_diff_.[[Microseconds]], ‚àí_diff_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _dateTime_).
        1. Let _result_ be ! BalanceDuration(‚àí_roundResult_.[[Days]], ‚àí_roundResult_.[[Hours]], ‚àí_roundResult_.[[Minutes]], ‚àí_roundResult_.[[Seconds]], ‚àí_roundResult_.[[Milliseconds]], ‚àí_roundResult_.[[Microseconds]], ‚àí_roundResult_.[[Nanoseconds]], _largestUnit_).
        1. Return ? CreateTemporalDuration(‚àí_roundResult_.[[Years]], ‚àí_roundResult_.[[Months]], ‚àí_roundResult_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.round">
      <h1>Temporal.PlainDateTime.prototype.round ( _options_ )</h1>
      <p>
        The `round` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If _options_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, ¬´ ¬ª).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. Let _roundingIncrement_ be ? ToTemporalDateTimeRoundingIncrement(_options_, _smallestUnit_).
        1. Let _result_ be ? RoundDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ? CreateTemporalDateTimeFromInstance(_dateTime_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.equals">
      <h1>Temporal.PlainDateTime.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Set _other_ to ? ToTemporalDateTime(_other_).
        1. If _dateTime_.[[ISOYear]] ‚â† _other_.[[ISOYear]], return *false*.
        1. If _dateTime_.[[ISOMonth]] ‚â† _other_.[[ISOMonth]], return *false*.
        1. If _dateTime_.[[ISODay]] ‚â† _other_.[[ISODay]], return *false*.
        1. If _dateTime_.[[Hour]] ‚â† _other_.[[Hour]], return *false*.
        1. If _dateTime_.[[Minute]] ‚â† _other_.[[Minute]], return *false*.
        1. If _dateTime_.[[Second]] ‚â† _other_.[[Second]], return *false*.
        1. If _dateTime_.[[Millisecond]] ‚â† _other_.[[Millisecond]], return *false*.
        1. If _dateTime_.[[Microsecond]] ‚â† _other_.[[Microsecond]], return *false*.
        1. If _dateTime_.[[Nanosecond]] ‚â† _other_.[[Nanosecond]], return *false*.
        1. Return ? CalendarEquals(_dateTime_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.tostring">
      <h1>Temporal.PlainDateTime.prototype.toString ( [ _options_ ] )</h1>
      <p>
        The `toString` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _precision_ be ? ToSecondsStringPrecision(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _showCalendar_ be ? ToShowCalendarOption(_options_).
        1. Let _result_ be ? RoundDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Return ? TemporalDateTimeToString(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _dateTime_.[[Calendar]], _precision_.[[Precision]], _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.tolocalestring">
      <h1>Temporal.PlainDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If the implementation does not include the ECMA-402 Internationalization API, then
          1. Return ? TemporalDateTimeToString(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]], _dateTime_.[[Calendar]], *"auto"*, *"auto"*).
        1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Return ? FormatDateTime(_dateFormat_, _dateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.tojson">
      <h1>Temporal.PlainDateTime.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? TemporalDateTimeToString(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]], _dateTime_.[[Calendar]], *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.valueof">
      <h1>Temporal.PlainDateTime.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.tozoneddatetime">
      <h1>Temporal.PlainDateTime.prototype.toZonedDateTime ( _temporalTimeZoneLike_ [ , _options_ ] )</h1>
      <p>
        The `toZonedDateTime` method takes two arguments, _temporalTimeZoneLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _timeZone_ be ? ToTemporalTimeZone(_temporalTimeZoneLike_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. Let _instant_ be ? GetTemporalInstantFor(_timeZone_, _dateTime_, _disambiguation_).
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.toplaindate">
      <h1>Temporal.PlainDateTime.prototype.toPlainDate ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? CreateTemporalDate(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.toplainyearmonth">
      <h1>Temporal.PlainDateTime.prototype.toPlainYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"year"* ¬ª).
        1. Let _fields_ be ? ToTemporalDateFields(_dateTime_, _fieldNames_).
        1. <mark>Create via calendar.yearMonthFromFields.</mark>
          Return ? CreateTemporalYearMonth(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.toplainmonthday">
      <h1>Temporal.PlainDateTime.prototype.toPlainMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"year"* ¬ª).
        1. Let _fields_ be ? ToTemporalDateFields(_dateTime_, _fieldNames_).
        1. <mark>Create via calendar.monthDayFromFields.</mark>
          Return ? CreateTemporalMonthDay(_dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.toplaintime">
      <h1>Temporal.PlainDateTime.prototype.toPlainTime ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? CreateTemporalTime(_dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.getfields">
      <h1>Temporal.PlainDateTime.prototype.getFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
        1. Let _fields_ be ? ToTemporalDateTimeFields(_dateTime_, _fieldNames_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _calendar_).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.getisofields">
      <h1>Temporal.PlainDateTime.prototype.getISOFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _fields_ be ? ObjectCreate(%ObjectPrototype%).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _dateTime_.[[Calendar]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"hour"*, ùîΩ(_dateTime_.[[Hour]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_dateTime_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_dateTime_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_dateTime_.[[ISOYear]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"microsecond"*, ùîΩ(_dateTime_.[[Microsecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"millisecond"*, ùîΩ(_dateTime_.[[Millisecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"minute"*, ùîΩ(_dateTime_.[[Minute]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"nanosecond"*, ùîΩ(_dateTime_.[[Nanosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"second"*, ùîΩ(_dateTime_.[[Second]])).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaindatetime-instances">
    <h1>Properties of Temporal.PlainDateTime Instances</h1>
    <p>
      Temporal.PlainDateTime instances are ordinary objects that inherit properties from the %Temporal.PlainDateTime.prototype% intrinsic object.
      Temporal.PlainDateTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldatetime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldatetime-instances" caption="Internal Slots of Temporal.PlainDateTime Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalDateTime]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.PlainDateTime instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOYear]]
            </td>
            <td>
              An integer Number value representing the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMonth]]
            </td>
            <td>
              An integer Number value between 1 and 12, inclusive, representing the month of the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISODay]]
            </td>
            <td>
              An integer Number value between 1 and DaysInMonth([[ISOYear]], [[ISOMonth]]), inclusive, representing the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[Hour]]
            </td>
            <td>
              An integer Number value between 0 and 23, inclusive, representing the hour of the day.
            </td>
          </tr>
          <tr>
            <td>
              [[Minute]]
            </td>
            <td>
              An integer Number value between 0 and 59, inclusive, representing the minute of the hour.
            </td>
          </tr>
          <tr>
            <td>
              [[Second]]
            </td>
            <td>
              An integer Number value between 0 and 59, inclusive, representing the second within the minute.
            </td>
          </tr>
          <tr>
            <td>
              [[Millisecond]]
            </td>
            <td>
              An integer Number value between 0 and 999, inclusive, representing the millisecond within the second.
            </td>
          </tr>
          <tr>
            <td>
              [[Microsecond]]
            </td>
            <td>
              An integer Number value between 0 and 999, inclusive, representing the microsecond within the millisecond.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanosecond]]
            </td>
            <td>
              An integer Number value between 0 and 999, inclusive, representing the nanosecond within the microsecond.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              An Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaindatetime-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-getepochfromparts" aoid="GetEpochFromParts">
      <h1>GetEpochFromParts ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integer Number values.
        1. Assert: _month_ ‚â• 1 and _month_ ‚â§ 12.
        1. Assert: _day_ ‚â• 1 and _day_ ‚â§ ! DaysInMonth(_year_, _month_).
        1. Assert: ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _date_ be ! MakeDay(_year_, _month_, _day_).
        1. Let _time_ be ! MakeTime(_hour_, _minute_, _second_, _millisecond_).
        1. Let _ms_ be ! MakeDate(_date_, _time_).
        1. Assert: _ms_ is finite.
        1. Return _ms_ √ó 1,000,000 + _microsecond_ √ó 1,000 + _nanosecond_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-plaindatetimewithinlimits" aoid="DateTimeWithinLimits">
      <h1>DateTimeWithinLimits ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-note>
        <p>
          Temporal.PlainDateTime objects can represent points in time within 24 hours (8.64 √ó 10<sup>16</sup> nanoseconds) of the Temporal.Instant boundaries
          This ensures that a Temporal.Instant object can be converted into a Temporal.PlainDateTime object using any time zone.
        </p>
      </emu-note>
      <emu-alg>
        1. Let _ns_ be ! GetEpochFromParts(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. If _ns_ ‚â§ -8.64 √ó 10<sup>21</sup><sub>‚Ñù</sub> - 8.64 √ó 10<sup>16</sup><sub>‚Ñù</sub>, then
          1. Return ~too early~.
        1. If _ns_ ‚â• 8.64 √ó 10<sup>21</sup><sub>‚Ñù</sub> + 8.64 √ó 10<sup>16</sup><sub>‚Ñù</sub>, then
          1. Return ~too late~.
        1. Return ~in range~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-interprettemporaldatetimefields" aoid="InterpretTemporalDateTimeFields">
      <h1>InterpretTemporalDateTimeFields ( _calendar_, _fields_, _overflow_ )</h1>
      <p>
        The abstract operation InterpretTemporalDateTimeFields interprets the date/time fields in the object _fields_ using the given _calendar_, and returns a Record with the fields according to the ISO calendar.
      </p>
      <emu-alg>
        1. Let _dateFromFields_ be ? Get(_calendar_, *"dateFromFields"*).
        1. Let _options_ be ! OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_options_, *"overflow"*, _overflow_).
        1. Let _temporalDate_ be ? Call(_dateFromFields_, _calendar_, ¬´ _fields_, _options_, %Temporal.PlainDate% ¬ª).
        1. Let _year_ be _temporalDate_.[[ISOYear]].
        1. Let _month_ be _temporalDate_.[[ISOMonth]].
        1. Let _day_ be _temporalDate_.[[ISODay]].
        1. Let _hour_ be ? Get(_fields_, *"hour"*).
        1. Let _minute_ be ? Get(_fields_, *"minute"*).
        1. Let _second_ be ? Get(_fields_, *"second"*).
        1. Let _millisecond_ be ? Get(_fields_, *"millisecond"*).
        1. Let _microsecond_ be ? Get(_fields_, *"microsecond"*).
        1. Let _nanosecond_ be ? Get(_fields_, *"nanosecond"*).
        1. Let _timeResult_ be ? RegulateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_).
        1. Return the new Record {
          [[Year]]: _year_,
          [[Month]]: _month_,
          [[Day]]: _day_,
          [[Hour]]: _timeResult_.[[Hour]],
          [[Minute]]: _timeResult_.[[Minute]],
          [[Second]]: _timeResult_.[[Second]],
          [[Millisecond]]: _timeResult_.[[Millisecond]],
          [[Microsecond]]: _timeResult_.[[Microsecond]],
          [[Nanosecond]]: _timeResult_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldatetime" aoid="ToTemporalDateTime">
      <h1>ToTemporalDateTime ( _item_ [ , _constructor_ [ , _overflow_ ] ] )</h1>
      <p>
        The abstract operation ToTemporalDateTime returns its argument _item_ if it is already a Temporal.PlainDateTime instance, converts _item_ to a new Temporal.PlainDateTime instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _constructor_ is not given, set it to %Temporal.PlainDateTime%.
        1. If _overflow_ is not given, set it to *"constrain"*.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Return _item_.
          1. Let _calendar_ be ? Get(_item_, *"calendar"*).
          1. If _calendar_ is *undefined*, set _calendar_ to ? GetISO8601Calendar().
          1. Set _calendar_ to ? ToTemporalCalendar(_calendar_).
          1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
          1. Let _fields_ be ? ToTemporalDateTimeFields(_item_, _fieldNames_).
          1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _overflow_).
        1. Else,
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalDateTimeString(_string_).
        1. Let _calendar_ be _result_.[[Calendar]].
        1. If _calendar_ is *undefined*, set _calendar_ to ? GetISO8601Calendar().
        1. Set _calendar_ to ? ToTemporalCalendar(_calendar_).
        1. Return ? CreateTemporalDateTimeFromStatic(_constructor_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-topartialdatetime" aoid="ToPartialDateTime">
      <h1>ToPartialDateTime ( _temporalDateTimeLike_, _fieldNames_ )</h1>
      <emu-alg>
        1. If Type(_temporalDateTimeLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? OrdinaryObjectCreate(%Object.prototype%).
        1. Let _any_ be *false*.
        1. For each value _property_ of _fieldNames_, do
          1. Let _value_ be ? Get(_temporalDateTimeLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
            1. If _property_ is one of *"day"*, *"month"*, or *"year"*, then
              1. Set _value_ to ? ToInteger(_value_).
            1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. For each row of <emu-xref href="#table-temporal-temporaltimelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalDateTimeLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
            1. Set _value_ to ? ToInteger(_value_).
            1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulatedatetime" aoid="RegulateDateTime">
      <h1>RegulateDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _overflow_ is one of *"constrain"* or *"reject"*.
        1. If _overflow_ is *"constrain"*, then
          1. Return ! ConstrainDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. If _overflow_ is *"reject"*, then
          1. If ! ValidateDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
            1. Throw a *RangeError* exception.
          1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_,
            [[Hour]]: _hour_,
            [[Minute]]: _minute_,
            [[Second]]: _second_,
            [[Millisecond]]: _millisecond_,
            [[Microsecond]]: _microsecond_,
            [[Nanosecond]]: _nanosecond_
            }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-validatedatetime" aoid="ValidateDateTime">
      <h1>ValidateDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integer Number values.
        1. If _month_ &lt; 1 or _month_ &gt; 12, then
          1. Return *false*.
        1. Let _maxDay_ be ! DaysInMonth(_year_, _month_).
        1. If _day_ &lt; 1 or _day_ &gt; _maxDay_, then
          1. Return *false*.
        1. If ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-constraindatetime" aoid="ConstrainDateTime">
      <h1>ConstrainDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integer Number values.
        1. Set _month_ to ! ConstrainToRange(_month_, 1, 12).
        1. Set _day_ to ! ConstrainToRange(_day_, 1, ! DaysInMonth(_year_, _month_)).
        1. Let _constrainedTime_ be ! ConstrainTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_,
            [[Hour]]: _constrainedTime_.[[Hour]],
            [[Minute]]: _constrainedTime_.[[Minute]],
            [[Second]]: _constrainedTime_.[[Second]],
            [[Millisecond]]: _constrainedTime_.[[Millisecond]],
            [[Microsecond]]: _constrainedTime_.[[Microsecond]],
            [[Nanosecond]]: _constrainedTime_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancedatetime" aoid="BalanceDateTime">
      <h1>BalanceDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Let _balancedTime_ be ? BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Let _balancedDate_ be ? BalanceDate(_year_, _month_, _day_ + _balancedTime_.[[Days]]).
        1. Return the Record {
            [[Year]]: _balancedDate_.[[Year]],
            [[Month]]: _balancedDate_.[[Month]],
            [[Day]]: _balancedDate_.[[Day]],
            [[Hour]]: _balancedTime_.[[Hour]],
            [[Minute]]: _balancedTime_.[[Minute]],
            [[Second]]: _balancedTime_.[[Second]],
            [[Millisecond]]: _balancedTime_.[[Millisecond]],
            [[Microsecond]]: _balancedTime_.[[Microsecond]],
            [[Nanosecond]]: _balancedTime_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetime" aoid="CreateTemporalDateTime">
      <h1>CreateTemporalDateTime ( _isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. If ! ValidateDateTime(_isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
          1. Throw a *RangeError* exception.
        1. If ! DateTimeWithinLimits(_isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is not ~in range~, then
          1. Throw a *RangeError* exception.
        1. If _newTarget_ is not given, set it to %Temporal.PlainDateTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%Temporal.PlainDateTime.prototype%"`, ¬´ [[InitializedTemporalDateTime]], [[ISOYear]], [[ISOMonth]], [[ISODay]], [[Hour]], [[Minute]], [[Second]], [[Millisecond]], [[Microsecond]], [[Nanosecond]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISOYear]] to _isoYear_.
        1. Set _object_.[[ISOMonth]] to _isoMonth_.
        1. Set _object_.[[ISODay]] to _isoDay_.
        1. Set _object_.[[Hour]] to _hour_.
        1. Set _object_.[[Minute]] to _minute_.
        1. Set _object_.[[Second]] to _second_.
        1. Set _object_.[[Millisecond]] to _millisecond_.
        1. Set _object_.[[Microsecond]] to _microsecond_.
        1. Set _object_.[[Nanosecond]] to _nanosecond_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetimefrominstance" aoid="CreateTemporalDateTimeFromInstance">
      <h1>CreateTemporalDateTimeFromInstance ( _dateTime_, _isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_ )</h1>
      <emu-alg>
        1. Assert: Type(_dateTime_) is Object and _dateTime_ has an [[InitializedTemporalDateTime]] internal slot.
        1. Assert: ! ValidateDateTime(_isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _constructor_ be ? SpeciesConstructor(_dateTime_, %Temporal.PlainDateTime%).
        1. Let _result_ be ? Construct(_constructor_, ¬´ _isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDateTime]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetimefromstatic" aoid="CreateTemporalDateTimeFromStatic">
      <h1>CreateTemporalDateTimeFromStatic ( _constructor_, _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_ )</h1>
      <emu-alg>
        1. Assert: ! ValidateDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. If ! IsConstructor(_constructor_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? Construct(_constructor_, ¬´ _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDateTime]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldatetimefields" aoid="ToTemporalDateTimeFields">
      <h1>ToTemporalDateTimeFields ( _temporalDateTimeLike_, _fieldNames_ )</h1>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. Assert: Type(_temporalDateTimeLike_) is Object.
        1. Let _result_ be ? OrdinaryObjectCreate(%Object.prototype%).
        1. For each value _property_ of _fieldNames_, do
          1. Let _value_ be ? Get(_temporalDateLike_, _property_).
          1. If _property_ is one of *"day"*, *"month"*, or *"year"*, then
            1. If _value_ is *undefined*, throw a *TypeError* exception.
            1. Set _value_ to ? ToInteger(_value_).
          1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. For each row of <emu-xref href="#table-temporal-temporaltimelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalDateTimeLike_, _property_).
          1. If _value_ is *undefined* and the Optional value of the current row is *false*, then
            1. Throw a *TypeError* exception.
          1. Let _value_ be ? ToInteger(_value_).
          1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetimetostring" aoid="TemporalDateTimeToString">
      <h1>TemporalDateTimeToString ( _isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_, _precision_, _showCalendar_ )</h1>
      <emu-alg>
        1. Let _year_ be ! PadYear(_isoYear_).
        1. Let _month_ be _isoMonth_ formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _isoDay_ formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _hour_ be _hour_ formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _minute_ be _minute_ formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _seconds_ be ! FormatSecondsStringPart(_second_, _millisecond_, _microsecond_, _nanosecond_, _precision_).
        1. Let _calendarString_ be ? FormatCalendarAnnotation(_calendar_, _showCalendar_).
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), _day_, 0x0054 (LATIN CAPITAL LETTER T), _hour_, the code unit 0x003A (COLON), _minute_, _seconds_, and _calendarString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaldatetime" aoid="CompareTemporalDateTime">
      <h1>CompareTemporalDateTime ( _y1_, _mon1_, _d1_, _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _y2_, _mon2_, _d2_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_ )</h1>
      <emu-alg>
        1. If _y1_ &gt; _y2_, return 1.
        1. If _y1_ &lt; _y2_, return -1.
        1. If _mon1_ &gt; _mon2_, return 1.
        1. If _mon1_ &lt; _mon2_, return -1.
        1. If _d1_ &gt; _d2_, return 1.
        1. If _d1_ &lt; _d2_, return -1.
        1. If _h1_ &gt; _h2_, return 1.
        1. If _h1_ &lt; _h2_, return -1.
        1. If _min1_ &gt; _min2_, return 1.
        1. If _min1_ &lt; _min2_, return -1.
        1. If _s1_ &gt; _s2_, return 1.
        1. If _s1_ &lt; _s2_, return -1.
        1. If _ms1_ &gt; _ms2_, return 1.
        1. If _ms1_ &lt; _ms2_, return -1.
        1. If _mus1_ &gt; _mus2_, return 1.
        1. If _mus1_ &lt; _mus2_, return -1.
        1. If _ns1_ &gt; _ns2_, return 1.
        1. If _ns1_ &lt; _ns2_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddatetime" aoid="AddDateTime">
      <h1>AddDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_, _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _overflow_ )</h1>
      <p>
        The abstract operation AddDateTime adds a duration to a combined date and time, according to the reckoning of the given _calendar_.
      </p>
      <emu-alg>
        1. Let _options_ be ! OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_options_, *"overflow"*, _overflow_).
        1. <mark>TODO: use `calendar.timeAdd()`</mark>.
        1. Let _timeResult_ be ? AddTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Let _datePart_ be ? CreateTemporalDate(_year_, _month_, _day_, _calendar_).
        1. Let _dateDuration_ be ? CreateTemporalDuration(_years_, _months_, _weeks_, _days_ + _timeResult_.[[Days]]).
        1. Let _dateAdd_ be ? Get(_calendar_, *"dateAdd"*).
        1. Let _addedDate_ be ? Call(_dateAdd_, _calendar_, ¬´ _datePart_, _dateDuration_, _options_, %Temporal.PlainDate% ¬ª).
        1. Return the new Record {
            [[Year]]: _addedDate_.[[ISOYear]],
            [[Month]]: _addedDate_.[[ISOMonth]],
            [[Day]]: _addedDate_.[[ISODay]],
            [[Hour]]: _timeResult_.[[Hour]],
            [[Minute]]: _timeResult_.[[Minute]],
            [[Second]]: _timeResult_.[[Second]],
            [[Millisecond]]: _timeResult_.[[Millisecond]],
            [[Microsecond]]: _timeResult_.[[Microsecond]],
            [[Nanosecond]]: _timeResult_.[[Nanosecond]],
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-rounddatetime" aoid="RoundDateTime">
      <h1>RoundDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _increment_, _unit_, _roundingMode_ )</h1>
      <p>
        The abstract operation RoundDateTime rounds the time part of a combined date and time, carrying over any excess into the date part.
      </p>
      <emu-alg>
        1. Let _roundedTime_ be ? RoundTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _increment_, _unit_, _roundingMode_).
        1. Let _balanceResult_ be ? BalanceDate(_year_, _month_, _day_ + _roundedTime_.[[Days]]).
        1. Return the new Record {
            [[Year]]: _balanceResult_.[[Year]],
            [[Month]]: _balanceResult_.[[Month]],
            [[Day]]: _balanceResult_.[[Day]],
            [[Hour]]: _roundedTime_.[[Hour]],
            [[Minute]]: _roundedTime_.[[Minute]],
            [[Second]]: _roundedTime_.[[Second]],
            [[Millisecond]]: _roundedTime_.[[Millisecond]],
            [[Microsecond]]: _roundedTime_.[[Microsecond]],
            [[Nanosecond]]: _roundedTime_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencedatetime" aoid="DifferenceDateTime">
      <h1>DifferenceDateTime ( _y1_, _mon1_, _d1_, _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _y2_, _mon2_, _d2_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_, _calendar_, _largestUnit_ )</h1>
      <p>
        The abstract operation DifferenceDateTime returns a Record with the elapsed duration from a first date and time, until a second date and time, according to the reckoning of the given _calendar_.
        The given date and time units are all in the ISO 8601 calendar.
        The _largestUnit_ argument is used in _calendar_'s `dateUntil` method.
      </p>
      <emu-alg>
        1. Let _time1_ be ? CreateTemporalTime(_h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _calendar_).
        1. Let _time2_ be ? CreateTemporalTime(_h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_, _calendar_).
        1. Let _timeUntil_ be ? Get(_calendar_, *"timeUntil"*).
        1. Let _timeDifference_ be ? Call(_timeUntil_, _calendar_, ¬´ _time1_, _time2_ ¬ª).
        1. Let _balanceResult_ be ? BalanceDate(_y1_, _mon1_, _d1_ + _timeDifference_.[[Days]]).
        1. Let _date1_ be ? CreateTemporalDate(_balanceResult_.[[Year]], _balanceResult_.[[Month]], _balanceResult_.[[Day]]).
        1. Let _date2_ be ? CreateTemporalDate(_y2_, _mon2_, _d2_).
        1. Let _dateUntil_ be ? Get(_calendar_, *"dateUntil"*).
        1. Let _dateLargestUnit_ be ! LargerOfTwoTemporalUnits(*"days"*, _largestUnit_).
        1. Let _options_ be ! OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_options_, *"largestUnit"*, _dateLargestUnit_).
        1. Let _dateDifference_ be ? Call(_dateUntil_, _calendar_, ¬´ _date1_, _date2_, _options_ ¬ª).
        1. Return ? BalanceDuration(_dateDifference_.[[Years]], _dateDifference_.[[Months]], _dateDifference_.[[Weeks]], _dateDifference_.[[Days]], _timeDifference_.[[Hours]], _timeDifference_.[[Minutes]], _timeDifference_.[[Seconds]], _timeDifference_.[[Milliseconds]], _timeDifference_.[[Microseconds]], _timeDifference_.[[Nanoseconds]], _largestUnit_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
